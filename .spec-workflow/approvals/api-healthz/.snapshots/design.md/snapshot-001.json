{
  "id": "snapshot_1766118756442_9oxwq431u",
  "approvalId": "approval_1766118756435_9sxauz8ns",
  "approvalTitle": "api-healthz design",
  "version": 1,
  "timestamp": "2025-12-19T04:32:36.442Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nAdd a lightweight `GET /healthz` endpoint in `apps/api` that always returns HTTP 200 with `{ status: \"ok\" }` and performs no external dependency checks. The endpoint is unauthenticated and intended for uptime monitoring.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\nNo steering documents are present. The design minimizes dependencies, keeps logic simple, and follows conventional Scala project layout.\n\n### Project Structure (structure.md)\nNo steering documents are present. The implementation will follow standard SBT/Scala source layout under `apps/api/src/main/scala` and match any existing routing conventions found in the module.\n\n## Code Reuse Analysis\nNo API source code exists yet under `apps/api/src`. The design assumes a minimal routing layer will either already exist or be introduced in the implementation task. The health check handler should reuse any existing JSON/rendering utilities if present.\n\n### Existing Components to Leverage\n- **None found**: `apps/api/src` has no Scala sources at this time.\n\n### Integration Points\n- **API routing layer**: Register `GET /healthz` alongside existing routes (if present).\n- **No database or external services**: The endpoint is intentionally standalone.\n\n## Architecture\n\nA single handler function returns a fixed JSON body and HTTP 200. The route is registered in the API router with no middleware requirements (no auth, no DB).\n\n### Modular Design Principles\n- **Single File Responsibility**: Keep the health handler focused on returning status only\n- **Component Isolation**: Avoid coupling to other services or infrastructure\n- **Service Layer Separation**: No service layer is needed for this endpoint\n- **Utility Modularity**: Reuse existing JSON helpers if available; otherwise return a literal JSON string\n\n```mermaid\ngraph TD\n    A[HTTP Router] --> B[Healthz Handler]\n```\n\n## Components and Interfaces\n\n### Healthz Route/Handler\n- **Purpose:** Serve `GET /healthz` with `{ status: \"ok\" }`\n- **Interfaces:** `GET /healthz` HTTP endpoint\n- **Dependencies:** None (no DB, no external services)\n- **Reuses:** Existing router and JSON utilities if present\n\n## Data Models\n\n### HealthzResponse\n```\ncase class HealthzResponse(status: String)\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Scenario 1:** Router initialization fails (outside scope)\n   - **Handling:** Standard API bootstrap error handling\n   - **User Impact:** Service fails to start; health endpoint unavailable\n\n2. **Scenario 2:** JSON serialization utility missing\n   - **Handling:** Return a hardcoded JSON string `{ \"status\": \"ok\" }`\n   - **User Impact:** None; response remains valid\n\n## Testing Strategy\n\n### Unit Testing\n- Test the handler returns HTTP 200 and the expected JSON body.\n\n### Integration Testing\n- Exercise the full route via HTTP request to `GET /healthz`.\n\n### End-to-End Testing\n- Optional uptime check hitting `GET /healthz` in a deployed environment.\n",
  "fileStats": {
    "size": 2961,
    "lines": 76,
    "lastModified": "2025-12-19T04:32:33.794Z"
  },
  "comments": []
}